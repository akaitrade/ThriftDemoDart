/// Autogenerated by Thrift Compiler (0.20.0)
/// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
///  @generated


// ignore_for_file: unused_import
library api.src.api;

import 'dart:async';
//import 'package:thrift/src/protocol/t_protocol.dart';
import 'package:thrift/thrift.dart';
import 'transaction_type.dart';
import 'smart_operation_state.dart';
import 'transaction_state.dart';
import 'tokens_list_sort_field.dart';
import 'token_holders_sort_field.dart';
import 'wallets_list_sort.dart';
import 'package:general/general.dart' as t_general;
import 'amount_commission.dart';
import 'cumulative_amount.dart';
import 'smart_contract_deploy.dart';
import 'smart_contract.dart';
import 'smart_contract_invocation.dart';
import 'transaction_id.dart';
import 'token_deploy_trans_info.dart';
import 'token_transfer_trans_info.dart';
import 'smart_deploy_trans_info.dart';
import 'smart_execution_trans_info.dart';
import 'extra_fee.dart';
import 'smart_state_trans_info.dart';
import 'smart_trans_info.dart';
import 'transaction.dart';
import 'sealed_transaction.dart';
import 'short_transaction.dart';
import 'pool.dart';
import 'delegated_item.dart';
import 'delegated.dart';
import 'wallet_data.dart';
import 'period_stats.dart';
import 'wallet_data_get_result.dart';
import 'wallet_id_get_result.dart';
import 'wallet_transactions_count_get_result.dart';
import 'wallet_balance_get_result.dart';
import 'transaction_get_result.dart';
import 'transactions_get_result.dart';
import 'transaction_flow_result.dart';
import 'single_token_query.dart';
import 'single_query.dart';
import 'transactions_query.dart';
import 'selected_token_transfers.dart';
import 'public_key_transactions.dart';
import 'filtered_transactions_list_result.dart';
import 'pool_list_get_result.dart';
import 'pool_info_get_result.dart';
import 'pool_transactions_get_result.dart';
import 'stats_get_result.dart';
import 'smart_contract_get_result.dart';
import 'smart_contract_addresses_list_get_result.dart';
import 'smart_contracts_list_get_result.dart';
import 'transactions_state_get_result.dart';
import 'smart_method_params_get_result.dart';
import 'contract_all_methods_get_result.dart';
import 'smart_contract_method_argument.dart';
import 'smart_contract_method.dart';
import 'smart_contract_data_result.dart';
import 'smart_contract_compile_result.dart';
import 'token_info.dart';
import 'token_transaction.dart';
import 'token_holder.dart';
import 'token_balance.dart';
import 'token_balances_result.dart';
import 'token_transfer.dart';
import 'token_transfers_result.dart';
import 'token_transactions_result.dart';
import 'token_info_result.dart';
import 'token_holders_result.dart';
import 'send_transaction_result.dart';
import 'tokens_list_result.dart';
import 'wallet_info.dart';
import 'actual_fee_get_result.dart';
import 'wallets_get_result.dart';
import 'trusted_info.dart';
import 'trusted_get_result.dart';
import 'sync_state_result.dart';
import 'execute_count_get_result.dart';
import 'token_filters.dart';
import 'transactions_list.dart';
import 'transactions_list_flow_result.dart';
import 'multiple_request_ids.dart';
import 'addresses.dart';
import 'wallet_balance.dart';
import 'wallet_balance_full.dart';
import 'wallet_balance_results.dart';
import 'accepted_request_id.dart';
import 'round_data.dart';


abstract class API {

  Future<ActualFeeGetResult> actualFeeGet(int transactionSize);

  Future<WalletDataGetResult> walletDataGet(Uint8List address);

  Future<WalletIdGetResult> walletIdGet(Uint8List address);

  Future<WalletTransactionsCountGetResult> walletTransactionsCountGet(Uint8List address);

  Future<WalletBalanceGetResult> walletBalanceGet(Uint8List address);

  Future<RoundData> roundDataGet();

  Future<AcceptedRequestId> walletsListBalancesGet(Addresses walletAddresses);

  Future<WalletBalanceResults> walletsListBalancesResultGet(int requestId);

  Future<TransactionGetResult> transactionGet(TransactionId transactionId);

  Future<TransactionsGetResult> transactionsGet(Uint8List address, int offset, int limit);

  Future<TransactionFlowResult> transactionFlow(Transaction transaction);

  Future<TransactionsGetResult> transactionsListGet(int offset, int limit);

  Future<FilteredTransactionsListResult> filteredTransactionsListGet(TransactionsQuery generalQuery);

  Future<AcceptedRequestId> filteredTrxsListGet(TransactionsQuery generalQuery);

  Future<FilteredTransactionsListResult> filteredTrxsListGetResult(int requestId);

  Future<SendTransactionResult> transactionSend(Transaction transaction);

  Future<TransactionFlowResult> transactionResultGet(int requestId);

  Future<SendTransactionResult> transactionsListSend(TransactionsList transactions);

  Future<TransactionsListFlowResult> transactionsListResultGet(int requestId);

  Future<Uint8List> getLastHash();

  Future<PoolListGetResult> poolListGetStable(int sequence, int limit);

  Future<PoolListGetResult> poolListGet(int offset, int limit);

  Future<PoolInfoGetResult> poolInfoGet(int sequence, int index);

  Future<PoolTransactionsGetResult> poolTransactionsGet(int sequence, int offset, int limit);

  Future<StatsGetResult> statsGet();

  Future<SmartContractGetResult> smartContractGet(Uint8List address);

  Future<SmartContractsListGetResult> smartContractsListGet(Uint8List deployer, int offset, int limit);

  Future<SmartContractAddressesListGetResult> smartContractAddressesListGet(Uint8List deployer);

  Future<Uint8List> waitForBlock(Uint8List obsolete);

  Future<TransactionId> waitForSmartTransaction(Uint8List smart_public);

  Future<SmartContractsListGetResult> smartContractsAllListGet(int offset, int limit);

  Future<TransactionsStateGetResult> transactionsStateGet(Uint8List address, List<int> id);

  Future<ContractAllMethodsGetResult> contractAllMethodsGet(List<t_general.ByteCodeObject> byteCodeObjects);

  Future<ContractAllMethodsGetResult> contractMethodsGet(Uint8List address);

  Future<SmartMethodParamsGetResult> smartMethodParamsGet(Uint8List address, int id);

  Future<SmartContractDataResult> smartContractDataGet(Uint8List address);

  Future<SmartContractCompileResult> smartContractCompile(String sourceCode, int lang);

  Future<TokenBalancesResult> tokenBalancesGet(Uint8List address);

  Future<TokenTransfersResult> tokenTransfersGet(Uint8List token, int offset, int limit);

  Future<TokenTransfersResult> tokenTransferGet(Uint8List token, TransactionId id);

  Future<TokenTransfersResult> tokenTransfersListGet(int offset, int limit);

  Future<TokenTransfersResult> tokenWalletTransfersGet(Uint8List token, Uint8List address, int offset, int limit);

  Future<TokenTransactionsResult> tokenTransactionsGet(Uint8List token, int offset, int limit);

  Future<TokenInfoResult> tokenInfoGet(Uint8List token);

  Future<TokenHoldersResult> tokenHoldersGet(Uint8List token, int offset, int limit, int order, bool desc);

  Future<TokensListResult> tokensListGet(int offset, int limit, int order, bool desc, TokenFilters filters);

  Future<WalletsGetResult> walletsGet(int offset, int limit, int ordCol, bool desc);

  Future<TrustedGetResult> trustedGet(int page);

  Future<SyncStateResult> syncStateGet();

  Future<ExecuteCountGetResult> executeCountGet(String executeMethod);
}

class APIClient implements API {

  APIClient(TProtocol iprot, [TProtocol oprot = null]) {
    _iprot = iprot;
    _oprot = (oprot == null) ? iprot : oprot;
  }

  TProtocol _iprot;

  TProtocol get iprot => _iprot;

  TProtocol _oprot;

  TProtocol get oprot => _oprot;

  int _seqid = 0;

  int get seqid => _seqid;

  int nextSeqid() => ++_seqid;

  Future<ActualFeeGetResult> actualFeeGet(int transactionSize) async {
    oprot.writeMessageBegin(new TMessage("ActualFeeGet", TMessageType.CALL, nextSeqid()));
    ActualFeeGet_args args = ActualFeeGet_args();
    args.transactionSize = transactionSize;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    ActualFeeGet_result result = ActualFeeGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "ActualFeeGet failed: unknown result");
  }

  Future<WalletDataGetResult> walletDataGet(Uint8List address) async {
    oprot.writeMessageBegin(new TMessage("WalletDataGet", TMessageType.CALL, nextSeqid()));
    WalletDataGet_args args = WalletDataGet_args();
    args.address = address;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    WalletDataGet_result result = WalletDataGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "WalletDataGet failed: unknown result");
  }

  Future<WalletIdGetResult> walletIdGet(Uint8List address) async {
    oprot.writeMessageBegin(new TMessage("WalletIdGet", TMessageType.CALL, nextSeqid()));
    WalletIdGet_args args = WalletIdGet_args();
    args.address = address;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    WalletIdGet_result result = WalletIdGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "WalletIdGet failed: unknown result");
  }

  Future<WalletTransactionsCountGetResult> walletTransactionsCountGet(Uint8List address) async {
    oprot.writeMessageBegin(new TMessage("WalletTransactionsCountGet", TMessageType.CALL, nextSeqid()));
    WalletTransactionsCountGet_args args = WalletTransactionsCountGet_args();
    args.address = address;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    WalletTransactionsCountGet_result result = WalletTransactionsCountGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "WalletTransactionsCountGet failed: unknown result");
  }

  Future<WalletBalanceGetResult> walletBalanceGet(Uint8List address) async {
    oprot.writeMessageBegin(new TMessage("WalletBalanceGet", TMessageType.CALL, nextSeqid()));
    WalletBalanceGet_args args = WalletBalanceGet_args();
    args.address = address;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    WalletBalanceGet_result result = WalletBalanceGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "WalletBalanceGet failed: unknown result");
  }

  Future<RoundData> roundDataGet() async {
    oprot.writeMessageBegin(new TMessage("RoundDataGet", TMessageType.CALL, nextSeqid()));
    RoundDataGet_args args = RoundDataGet_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    RoundDataGet_result result = RoundDataGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "RoundDataGet failed: unknown result");
  }

  Future<AcceptedRequestId> walletsListBalancesGet(Addresses walletAddresses) async {
    oprot.writeMessageBegin(new TMessage("WalletsListBalancesGet", TMessageType.CALL, nextSeqid()));
    WalletsListBalancesGet_args args = WalletsListBalancesGet_args();
    args.walletAddresses = walletAddresses;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    WalletsListBalancesGet_result result = WalletsListBalancesGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "WalletsListBalancesGet failed: unknown result");
  }

  Future<WalletBalanceResults> walletsListBalancesResultGet(int requestId) async {
    oprot.writeMessageBegin(new TMessage("WalletsListBalancesResultGet", TMessageType.CALL, nextSeqid()));
    WalletsListBalancesResultGet_args args = WalletsListBalancesResultGet_args();
    args.requestId = requestId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    WalletsListBalancesResultGet_result result = WalletsListBalancesResultGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "WalletsListBalancesResultGet failed: unknown result");
  }

  Future<TransactionGetResult> transactionGet(TransactionId transactionId) async {
    oprot.writeMessageBegin(new TMessage("TransactionGet", TMessageType.CALL, nextSeqid()));
    TransactionGet_args args = TransactionGet_args();
    args.transactionId = transactionId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TransactionGet_result result = TransactionGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TransactionGet failed: unknown result");
  }

  Future<TransactionsGetResult> transactionsGet(Uint8List address, int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("TransactionsGet", TMessageType.CALL, nextSeqid()));
    TransactionsGet_args args = TransactionsGet_args();
    args.address = address;
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TransactionsGet_result result = TransactionsGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TransactionsGet failed: unknown result");
  }

  Future<TransactionFlowResult> transactionFlow(Transaction transaction) async {
    oprot.writeMessageBegin(new TMessage("TransactionFlow", TMessageType.CALL, nextSeqid()));
    TransactionFlow_args args = TransactionFlow_args();
    args.transaction = transaction;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TransactionFlow_result result = TransactionFlow_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TransactionFlow failed: unknown result");
  }

  Future<TransactionsGetResult> transactionsListGet(int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("TransactionsListGet", TMessageType.CALL, nextSeqid()));
    TransactionsListGet_args args = TransactionsListGet_args();
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TransactionsListGet_result result = TransactionsListGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TransactionsListGet failed: unknown result");
  }

  Future<FilteredTransactionsListResult> filteredTransactionsListGet(TransactionsQuery generalQuery) async {
    oprot.writeMessageBegin(new TMessage("FilteredTransactionsListGet", TMessageType.CALL, nextSeqid()));
    FilteredTransactionsListGet_args args = FilteredTransactionsListGet_args();
    args.generalQuery = generalQuery;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    FilteredTransactionsListGet_result result = FilteredTransactionsListGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "FilteredTransactionsListGet failed: unknown result");
  }

  Future<AcceptedRequestId> filteredTrxsListGet(TransactionsQuery generalQuery) async {
    oprot.writeMessageBegin(new TMessage("FilteredTrxsListGet", TMessageType.CALL, nextSeqid()));
    FilteredTrxsListGet_args args = FilteredTrxsListGet_args();
    args.generalQuery = generalQuery;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    FilteredTrxsListGet_result result = FilteredTrxsListGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "FilteredTrxsListGet failed: unknown result");
  }

  Future<FilteredTransactionsListResult> filteredTrxsListGetResult(int requestId) async {
    oprot.writeMessageBegin(new TMessage("FilteredTrxsListGetResult", TMessageType.CALL, nextSeqid()));
    FilteredTrxsListGetResult_args args = FilteredTrxsListGetResult_args();
    args.requestId = requestId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    FilteredTrxsListGetResult_result result = FilteredTrxsListGetResult_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "FilteredTrxsListGetResult failed: unknown result");
  }

  Future<SendTransactionResult> transactionSend(Transaction transaction) async {
    oprot.writeMessageBegin(new TMessage("TransactionSend", TMessageType.CALL, nextSeqid()));
    TransactionSend_args args = TransactionSend_args();
    args.transaction = transaction;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TransactionSend_result result = TransactionSend_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TransactionSend failed: unknown result");
  }

  Future<TransactionFlowResult> transactionResultGet(int requestId) async {
    oprot.writeMessageBegin(new TMessage("TransactionResultGet", TMessageType.CALL, nextSeqid()));
    TransactionResultGet_args args = TransactionResultGet_args();
    args.requestId = requestId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TransactionResultGet_result result = TransactionResultGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TransactionResultGet failed: unknown result");
  }

  Future<SendTransactionResult> transactionsListSend(TransactionsList transactions) async {
    oprot.writeMessageBegin(new TMessage("TransactionsListSend", TMessageType.CALL, nextSeqid()));
    TransactionsListSend_args args = TransactionsListSend_args();
    args.transactions = transactions;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TransactionsListSend_result result = TransactionsListSend_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TransactionsListSend failed: unknown result");
  }

  Future<TransactionsListFlowResult> transactionsListResultGet(int requestId) async {
    oprot.writeMessageBegin(new TMessage("TransactionsListResultGet", TMessageType.CALL, nextSeqid()));
    TransactionsListResultGet_args args = TransactionsListResultGet_args();
    args.requestId = requestId;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TransactionsListResultGet_result result = TransactionsListResultGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TransactionsListResultGet failed: unknown result");
  }

  Future<Uint8List> getLastHash() async {
    oprot.writeMessageBegin(new TMessage("GetLastHash", TMessageType.CALL, nextSeqid()));
    GetLastHash_args args = GetLastHash_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    GetLastHash_result result = GetLastHash_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "GetLastHash failed: unknown result");
  }

  Future<PoolListGetResult> poolListGetStable(int sequence, int limit) async {
    oprot.writeMessageBegin(new TMessage("PoolListGetStable", TMessageType.CALL, nextSeqid()));
    PoolListGetStable_args args = PoolListGetStable_args();
    args.sequence = sequence;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    PoolListGetStable_result result = PoolListGetStable_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "PoolListGetStable failed: unknown result");
  }

  Future<PoolListGetResult> poolListGet(int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("PoolListGet", TMessageType.CALL, nextSeqid()));
    PoolListGet_args args = PoolListGet_args();
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    PoolListGet_result result = PoolListGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "PoolListGet failed: unknown result");
  }

  Future<PoolInfoGetResult> poolInfoGet(int sequence, int index) async {
    oprot.writeMessageBegin(new TMessage("PoolInfoGet", TMessageType.CALL, nextSeqid()));
    PoolInfoGet_args args = PoolInfoGet_args();
    args.sequence = sequence;
    args.index = index;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    PoolInfoGet_result result = PoolInfoGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "PoolInfoGet failed: unknown result");
  }

  Future<PoolTransactionsGetResult> poolTransactionsGet(int sequence, int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("PoolTransactionsGet", TMessageType.CALL, nextSeqid()));
    PoolTransactionsGet_args args = PoolTransactionsGet_args();
    args.sequence = sequence;
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    PoolTransactionsGet_result result = PoolTransactionsGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "PoolTransactionsGet failed: unknown result");
  }

  Future<StatsGetResult> statsGet() async {
    oprot.writeMessageBegin(new TMessage("StatsGet", TMessageType.CALL, nextSeqid()));
    StatsGet_args args = StatsGet_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    StatsGet_result result = StatsGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "StatsGet failed: unknown result");
  }

  Future<SmartContractGetResult> smartContractGet(Uint8List address) async {
    oprot.writeMessageBegin(new TMessage("SmartContractGet", TMessageType.CALL, nextSeqid()));
    SmartContractGet_args args = SmartContractGet_args();
    args.address = address;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    SmartContractGet_result result = SmartContractGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "SmartContractGet failed: unknown result");
  }

  Future<SmartContractsListGetResult> smartContractsListGet(Uint8List deployer, int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("SmartContractsListGet", TMessageType.CALL, nextSeqid()));
    SmartContractsListGet_args args = SmartContractsListGet_args();
    args.deployer = deployer;
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    SmartContractsListGet_result result = SmartContractsListGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "SmartContractsListGet failed: unknown result");
  }

  Future<SmartContractAddressesListGetResult> smartContractAddressesListGet(Uint8List deployer) async {
    oprot.writeMessageBegin(new TMessage("SmartContractAddressesListGet", TMessageType.CALL, nextSeqid()));
    SmartContractAddressesListGet_args args = SmartContractAddressesListGet_args();
    args.deployer = deployer;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    SmartContractAddressesListGet_result result = SmartContractAddressesListGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "SmartContractAddressesListGet failed: unknown result");
  }

  Future<Uint8List> waitForBlock(Uint8List obsolete) async {
    oprot.writeMessageBegin(new TMessage("WaitForBlock", TMessageType.CALL, nextSeqid()));
    WaitForBlock_args args = WaitForBlock_args();
    args.obsolete = obsolete;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    WaitForBlock_result result = WaitForBlock_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "WaitForBlock failed: unknown result");
  }

  Future<TransactionId> waitForSmartTransaction(Uint8List smart_public) async {
    oprot.writeMessageBegin(new TMessage("WaitForSmartTransaction", TMessageType.CALL, nextSeqid()));
    WaitForSmartTransaction_args args = WaitForSmartTransaction_args();
    args.smart_public = smart_public;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    WaitForSmartTransaction_result result = WaitForSmartTransaction_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "WaitForSmartTransaction failed: unknown result");
  }

  Future<SmartContractsListGetResult> smartContractsAllListGet(int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("SmartContractsAllListGet", TMessageType.CALL, nextSeqid()));
    SmartContractsAllListGet_args args = SmartContractsAllListGet_args();
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    SmartContractsAllListGet_result result = SmartContractsAllListGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "SmartContractsAllListGet failed: unknown result");
  }

  Future<TransactionsStateGetResult> transactionsStateGet(Uint8List address, List<int> id) async {
    oprot.writeMessageBegin(new TMessage("TransactionsStateGet", TMessageType.CALL, nextSeqid()));
    TransactionsStateGet_args args = TransactionsStateGet_args();
    args.address = address;
    args.id = id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TransactionsStateGet_result result = TransactionsStateGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TransactionsStateGet failed: unknown result");
  }

  Future<ContractAllMethodsGetResult> contractAllMethodsGet(List<t_general.ByteCodeObject> byteCodeObjects) async {
    oprot.writeMessageBegin(new TMessage("ContractAllMethodsGet", TMessageType.CALL, nextSeqid()));
    ContractAllMethodsGet_args args = ContractAllMethodsGet_args();
    args.byteCodeObjects = byteCodeObjects;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    ContractAllMethodsGet_result result = ContractAllMethodsGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "ContractAllMethodsGet failed: unknown result");
  }

  Future<ContractAllMethodsGetResult> contractMethodsGet(Uint8List address) async {
    oprot.writeMessageBegin(new TMessage("ContractMethodsGet", TMessageType.CALL, nextSeqid()));
    ContractMethodsGet_args args = ContractMethodsGet_args();
    args.address = address;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    ContractMethodsGet_result result = ContractMethodsGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "ContractMethodsGet failed: unknown result");
  }

  Future<SmartMethodParamsGetResult> smartMethodParamsGet(Uint8List address, int id) async {
    oprot.writeMessageBegin(new TMessage("SmartMethodParamsGet", TMessageType.CALL, nextSeqid()));
    SmartMethodParamsGet_args args = SmartMethodParamsGet_args();
    args.address = address;
    args.id = id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    SmartMethodParamsGet_result result = SmartMethodParamsGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "SmartMethodParamsGet failed: unknown result");
  }

  Future<SmartContractDataResult> smartContractDataGet(Uint8List address) async {
    oprot.writeMessageBegin(new TMessage("SmartContractDataGet", TMessageType.CALL, nextSeqid()));
    SmartContractDataGet_args args = SmartContractDataGet_args();
    args.address = address;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    SmartContractDataGet_result result = SmartContractDataGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "SmartContractDataGet failed: unknown result");
  }

  Future<SmartContractCompileResult> smartContractCompile(String sourceCode, int lang) async {
    oprot.writeMessageBegin(new TMessage("SmartContractCompile", TMessageType.CALL, nextSeqid()));
    SmartContractCompile_args args = SmartContractCompile_args();
    args.sourceCode = sourceCode;
    args.lang = lang;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    SmartContractCompile_result result = SmartContractCompile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "SmartContractCompile failed: unknown result");
  }

  Future<TokenBalancesResult> tokenBalancesGet(Uint8List address) async {
    oprot.writeMessageBegin(new TMessage("TokenBalancesGet", TMessageType.CALL, nextSeqid()));
    TokenBalancesGet_args args = TokenBalancesGet_args();
    args.address = address;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TokenBalancesGet_result result = TokenBalancesGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TokenBalancesGet failed: unknown result");
  }

  Future<TokenTransfersResult> tokenTransfersGet(Uint8List token, int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("TokenTransfersGet", TMessageType.CALL, nextSeqid()));
    TokenTransfersGet_args args = TokenTransfersGet_args();
    args.token = token;
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TokenTransfersGet_result result = TokenTransfersGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TokenTransfersGet failed: unknown result");
  }

  Future<TokenTransfersResult> tokenTransferGet(Uint8List token, TransactionId id) async {
    oprot.writeMessageBegin(new TMessage("TokenTransferGet", TMessageType.CALL, nextSeqid()));
    TokenTransferGet_args args = TokenTransferGet_args();
    args.token = token;
    args.id = id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TokenTransferGet_result result = TokenTransferGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TokenTransferGet failed: unknown result");
  }

  Future<TokenTransfersResult> tokenTransfersListGet(int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("TokenTransfersListGet", TMessageType.CALL, nextSeqid()));
    TokenTransfersListGet_args args = TokenTransfersListGet_args();
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TokenTransfersListGet_result result = TokenTransfersListGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TokenTransfersListGet failed: unknown result");
  }

  Future<TokenTransfersResult> tokenWalletTransfersGet(Uint8List token, Uint8List address, int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("TokenWalletTransfersGet", TMessageType.CALL, nextSeqid()));
    TokenWalletTransfersGet_args args = TokenWalletTransfersGet_args();
    args.token = token;
    args.address = address;
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TokenWalletTransfersGet_result result = TokenWalletTransfersGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TokenWalletTransfersGet failed: unknown result");
  }

  Future<TokenTransactionsResult> tokenTransactionsGet(Uint8List token, int offset, int limit) async {
    oprot.writeMessageBegin(new TMessage("TokenTransactionsGet", TMessageType.CALL, nextSeqid()));
    TokenTransactionsGet_args args = TokenTransactionsGet_args();
    args.token = token;
    args.offset = offset;
    args.limit = limit;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TokenTransactionsGet_result result = TokenTransactionsGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TokenTransactionsGet failed: unknown result");
  }

  Future<TokenInfoResult> tokenInfoGet(Uint8List token) async {
    oprot.writeMessageBegin(new TMessage("TokenInfoGet", TMessageType.CALL, nextSeqid()));
    TokenInfoGet_args args = TokenInfoGet_args();
    args.token = token;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TokenInfoGet_result result = TokenInfoGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TokenInfoGet failed: unknown result");
  }

  Future<TokenHoldersResult> tokenHoldersGet(Uint8List token, int offset, int limit, int order, bool desc) async {
    oprot.writeMessageBegin(new TMessage("TokenHoldersGet", TMessageType.CALL, nextSeqid()));
    TokenHoldersGet_args args = TokenHoldersGet_args();
    args.token = token;
    args.offset = offset;
    args.limit = limit;
    args.order = order;
    args.desc = desc;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TokenHoldersGet_result result = TokenHoldersGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TokenHoldersGet failed: unknown result");
  }

  Future<TokensListResult> tokensListGet(int offset, int limit, int order, bool desc, TokenFilters filters) async {
    oprot.writeMessageBegin(new TMessage("TokensListGet", TMessageType.CALL, nextSeqid()));
    TokensListGet_args args = TokensListGet_args();
    args.offset = offset;
    args.limit = limit;
    args.order = order;
    args.desc = desc;
    args.filters = filters;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TokensListGet_result result = TokensListGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TokensListGet failed: unknown result");
  }

  Future<WalletsGetResult> walletsGet(int offset, int limit, int ordCol, bool desc) async {
    oprot.writeMessageBegin(new TMessage("WalletsGet", TMessageType.CALL, nextSeqid()));
    WalletsGet_args args = WalletsGet_args();
    args.offset = offset;
    args.limit = limit;
    args.ordCol = ordCol;
    args.desc = desc;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    WalletsGet_result result = WalletsGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "WalletsGet failed: unknown result");
  }

  Future<TrustedGetResult> trustedGet(int page) async {
    oprot.writeMessageBegin(new TMessage("TrustedGet", TMessageType.CALL, nextSeqid()));
    TrustedGet_args args = TrustedGet_args();
    args.page = page;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    TrustedGet_result result = TrustedGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "TrustedGet failed: unknown result");
  }

  Future<SyncStateResult> syncStateGet() async {
    oprot.writeMessageBegin(new TMessage("SyncStateGet", TMessageType.CALL, nextSeqid()));
    SyncStateGet_args args = SyncStateGet_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    SyncStateGet_result result = SyncStateGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "SyncStateGet failed: unknown result");
  }

  Future<ExecuteCountGetResult> executeCountGet(String executeMethod) async {
    oprot.writeMessageBegin(new TMessage("ExecuteCountGet", TMessageType.CALL, nextSeqid()));
    ExecuteCountGet_args args = ExecuteCountGet_args();
    args.executeMethod = executeMethod;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    ExecuteCountGet_result result = ExecuteCountGet_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw TApplicationError(TApplicationErrorType.MISSING_RESULT, "ExecuteCountGet failed: unknown result");
  }

}

typedef void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);

class APIProcessor implements TProcessor {
  APIProcessor(API iface) {
    iface_ = iface;
    PROCESS_MAP["ActualFeeGet"] = actualFeeGet;
    PROCESS_MAP["WalletDataGet"] = walletDataGet;
    PROCESS_MAP["WalletIdGet"] = walletIdGet;
    PROCESS_MAP["WalletTransactionsCountGet"] = walletTransactionsCountGet;
    PROCESS_MAP["WalletBalanceGet"] = walletBalanceGet;
    PROCESS_MAP["RoundDataGet"] = roundDataGet;
    PROCESS_MAP["WalletsListBalancesGet"] = walletsListBalancesGet;
    PROCESS_MAP["WalletsListBalancesResultGet"] = walletsListBalancesResultGet;
    PROCESS_MAP["TransactionGet"] = transactionGet;
    PROCESS_MAP["TransactionsGet"] = transactionsGet;
    PROCESS_MAP["TransactionFlow"] = transactionFlow;
    PROCESS_MAP["TransactionsListGet"] = transactionsListGet;
    PROCESS_MAP["FilteredTransactionsListGet"] = filteredTransactionsListGet;
    PROCESS_MAP["FilteredTrxsListGet"] = filteredTrxsListGet;
    PROCESS_MAP["FilteredTrxsListGetResult"] = filteredTrxsListGetResult;
    PROCESS_MAP["TransactionSend"] = transactionSend;
    PROCESS_MAP["TransactionResultGet"] = transactionResultGet;
    PROCESS_MAP["TransactionsListSend"] = transactionsListSend;
    PROCESS_MAP["TransactionsListResultGet"] = transactionsListResultGet;
    PROCESS_MAP["GetLastHash"] = getLastHash;
    PROCESS_MAP["PoolListGetStable"] = poolListGetStable;
    PROCESS_MAP["PoolListGet"] = poolListGet;
    PROCESS_MAP["PoolInfoGet"] = poolInfoGet;
    PROCESS_MAP["PoolTransactionsGet"] = poolTransactionsGet;
    PROCESS_MAP["StatsGet"] = statsGet;
    PROCESS_MAP["SmartContractGet"] = smartContractGet;
    PROCESS_MAP["SmartContractsListGet"] = smartContractsListGet;
    PROCESS_MAP["SmartContractAddressesListGet"] = smartContractAddressesListGet;
    PROCESS_MAP["WaitForBlock"] = waitForBlock;
    PROCESS_MAP["WaitForSmartTransaction"] = waitForSmartTransaction;
    PROCESS_MAP["SmartContractsAllListGet"] = smartContractsAllListGet;
    PROCESS_MAP["TransactionsStateGet"] = transactionsStateGet;
    PROCESS_MAP["ContractAllMethodsGet"] = contractAllMethodsGet;
    PROCESS_MAP["ContractMethodsGet"] = contractMethodsGet;
    PROCESS_MAP["SmartMethodParamsGet"] = smartMethodParamsGet;
    PROCESS_MAP["SmartContractDataGet"] = smartContractDataGet;
    PROCESS_MAP["SmartContractCompile"] = smartContractCompile;
    PROCESS_MAP["TokenBalancesGet"] = tokenBalancesGet;
    PROCESS_MAP["TokenTransfersGet"] = tokenTransfersGet;
    PROCESS_MAP["TokenTransferGet"] = tokenTransferGet;
    PROCESS_MAP["TokenTransfersListGet"] = tokenTransfersListGet;
    PROCESS_MAP["TokenWalletTransfersGet"] = tokenWalletTransfersGet;
    PROCESS_MAP["TokenTransactionsGet"] = tokenTransactionsGet;
    PROCESS_MAP["TokenInfoGet"] = tokenInfoGet;
    PROCESS_MAP["TokenHoldersGet"] = tokenHoldersGet;
    PROCESS_MAP["TokensListGet"] = tokensListGet;
    PROCESS_MAP["WalletsGet"] = walletsGet;
    PROCESS_MAP["TrustedGet"] = trustedGet;
    PROCESS_MAP["SyncStateGet"] = syncStateGet;
    PROCESS_MAP["ExecuteCountGet"] = executeCountGet;
  }

  API iface_;
  final Map<String, ProcessFunction> PROCESS_MAP = {};

  bool process(TProtocol iprot, TProtocol oprot) {
    TMessage msg = iprot.readMessageBegin();
    ProcessFunction fn = PROCESS_MAP[msg.name];
    if (fn == null) {
      TProtocolUtil.skip(iprot, TType.STRUCT);
      iprot.readMessageEnd();
      TApplicationError x = TApplicationError(TApplicationErrorType.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
      oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return true;
    }
    fn(msg.seqid, iprot, oprot);
    return true;
  }

  actualFeeGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    ActualFeeGet_args args = ActualFeeGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    ActualFeeGet_result result = ActualFeeGet_result();
    result.success = await iface_.actualFeeGet(args.transactionSize);
    oprot.writeMessageBegin(new TMessage("ActualFeeGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  walletDataGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    WalletDataGet_args args = WalletDataGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    WalletDataGet_result result = WalletDataGet_result();
    result.success = await iface_.walletDataGet(args.address);
    oprot.writeMessageBegin(new TMessage("WalletDataGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  walletIdGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    WalletIdGet_args args = WalletIdGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    WalletIdGet_result result = WalletIdGet_result();
    result.success = await iface_.walletIdGet(args.address);
    oprot.writeMessageBegin(new TMessage("WalletIdGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  walletTransactionsCountGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    WalletTransactionsCountGet_args args = WalletTransactionsCountGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    WalletTransactionsCountGet_result result = WalletTransactionsCountGet_result();
    result.success = await iface_.walletTransactionsCountGet(args.address);
    oprot.writeMessageBegin(new TMessage("WalletTransactionsCountGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  walletBalanceGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    WalletBalanceGet_args args = WalletBalanceGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    WalletBalanceGet_result result = WalletBalanceGet_result();
    result.success = await iface_.walletBalanceGet(args.address);
    oprot.writeMessageBegin(new TMessage("WalletBalanceGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  roundDataGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    RoundDataGet_args args = RoundDataGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    RoundDataGet_result result = RoundDataGet_result();
    result.success = await iface_.roundDataGet();
    oprot.writeMessageBegin(new TMessage("RoundDataGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  walletsListBalancesGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    WalletsListBalancesGet_args args = WalletsListBalancesGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    WalletsListBalancesGet_result result = WalletsListBalancesGet_result();
    result.success = await iface_.walletsListBalancesGet(args.walletAddresses);
    oprot.writeMessageBegin(new TMessage("WalletsListBalancesGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  walletsListBalancesResultGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    WalletsListBalancesResultGet_args args = WalletsListBalancesResultGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    WalletsListBalancesResultGet_result result = WalletsListBalancesResultGet_result();
    result.success = await iface_.walletsListBalancesResultGet(args.requestId);
    oprot.writeMessageBegin(new TMessage("WalletsListBalancesResultGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  transactionGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TransactionGet_args args = TransactionGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TransactionGet_result result = TransactionGet_result();
    result.success = await iface_.transactionGet(args.transactionId);
    oprot.writeMessageBegin(new TMessage("TransactionGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  transactionsGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TransactionsGet_args args = TransactionsGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TransactionsGet_result result = TransactionsGet_result();
    result.success = await iface_.transactionsGet(args.address, args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("TransactionsGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  transactionFlow(int seqid, TProtocol iprot, TProtocol oprot) async {
    TransactionFlow_args args = TransactionFlow_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TransactionFlow_result result = TransactionFlow_result();
    result.success = await iface_.transactionFlow(args.transaction);
    oprot.writeMessageBegin(new TMessage("TransactionFlow", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  transactionsListGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TransactionsListGet_args args = TransactionsListGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TransactionsListGet_result result = TransactionsListGet_result();
    result.success = await iface_.transactionsListGet(args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("TransactionsListGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  filteredTransactionsListGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    FilteredTransactionsListGet_args args = FilteredTransactionsListGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    FilteredTransactionsListGet_result result = FilteredTransactionsListGet_result();
    result.success = await iface_.filteredTransactionsListGet(args.generalQuery);
    oprot.writeMessageBegin(new TMessage("FilteredTransactionsListGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  filteredTrxsListGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    FilteredTrxsListGet_args args = FilteredTrxsListGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    FilteredTrxsListGet_result result = FilteredTrxsListGet_result();
    result.success = await iface_.filteredTrxsListGet(args.generalQuery);
    oprot.writeMessageBegin(new TMessage("FilteredTrxsListGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  filteredTrxsListGetResult(int seqid, TProtocol iprot, TProtocol oprot) async {
    FilteredTrxsListGetResult_args args = FilteredTrxsListGetResult_args();
    args.read(iprot);
    iprot.readMessageEnd();
    FilteredTrxsListGetResult_result result = FilteredTrxsListGetResult_result();
    result.success = await iface_.filteredTrxsListGetResult(args.requestId);
    oprot.writeMessageBegin(new TMessage("FilteredTrxsListGetResult", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  transactionSend(int seqid, TProtocol iprot, TProtocol oprot) async {
    TransactionSend_args args = TransactionSend_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TransactionSend_result result = TransactionSend_result();
    result.success = await iface_.transactionSend(args.transaction);
    oprot.writeMessageBegin(new TMessage("TransactionSend", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  transactionResultGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TransactionResultGet_args args = TransactionResultGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TransactionResultGet_result result = TransactionResultGet_result();
    result.success = await iface_.transactionResultGet(args.requestId);
    oprot.writeMessageBegin(new TMessage("TransactionResultGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  transactionsListSend(int seqid, TProtocol iprot, TProtocol oprot) async {
    TransactionsListSend_args args = TransactionsListSend_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TransactionsListSend_result result = TransactionsListSend_result();
    result.success = await iface_.transactionsListSend(args.transactions);
    oprot.writeMessageBegin(new TMessage("TransactionsListSend", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  transactionsListResultGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TransactionsListResultGet_args args = TransactionsListResultGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TransactionsListResultGet_result result = TransactionsListResultGet_result();
    result.success = await iface_.transactionsListResultGet(args.requestId);
    oprot.writeMessageBegin(new TMessage("TransactionsListResultGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  getLastHash(int seqid, TProtocol iprot, TProtocol oprot) async {
    GetLastHash_args args = GetLastHash_args();
    args.read(iprot);
    iprot.readMessageEnd();
    GetLastHash_result result = GetLastHash_result();
    result.success = await iface_.getLastHash();
    oprot.writeMessageBegin(new TMessage("GetLastHash", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  poolListGetStable(int seqid, TProtocol iprot, TProtocol oprot) async {
    PoolListGetStable_args args = PoolListGetStable_args();
    args.read(iprot);
    iprot.readMessageEnd();
    PoolListGetStable_result result = PoolListGetStable_result();
    result.success = await iface_.poolListGetStable(args.sequence, args.limit);
    oprot.writeMessageBegin(new TMessage("PoolListGetStable", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  poolListGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    PoolListGet_args args = PoolListGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    PoolListGet_result result = PoolListGet_result();
    result.success = await iface_.poolListGet(args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("PoolListGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  poolInfoGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    PoolInfoGet_args args = PoolInfoGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    PoolInfoGet_result result = PoolInfoGet_result();
    result.success = await iface_.poolInfoGet(args.sequence, args.index);
    oprot.writeMessageBegin(new TMessage("PoolInfoGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  poolTransactionsGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    PoolTransactionsGet_args args = PoolTransactionsGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    PoolTransactionsGet_result result = PoolTransactionsGet_result();
    result.success = await iface_.poolTransactionsGet(args.sequence, args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("PoolTransactionsGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  statsGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    StatsGet_args args = StatsGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    StatsGet_result result = StatsGet_result();
    result.success = await iface_.statsGet();
    oprot.writeMessageBegin(new TMessage("StatsGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  smartContractGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    SmartContractGet_args args = SmartContractGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    SmartContractGet_result result = SmartContractGet_result();
    result.success = await iface_.smartContractGet(args.address);
    oprot.writeMessageBegin(new TMessage("SmartContractGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  smartContractsListGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    SmartContractsListGet_args args = SmartContractsListGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    SmartContractsListGet_result result = SmartContractsListGet_result();
    result.success = await iface_.smartContractsListGet(args.deployer, args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("SmartContractsListGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  smartContractAddressesListGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    SmartContractAddressesListGet_args args = SmartContractAddressesListGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    SmartContractAddressesListGet_result result = SmartContractAddressesListGet_result();
    result.success = await iface_.smartContractAddressesListGet(args.deployer);
    oprot.writeMessageBegin(new TMessage("SmartContractAddressesListGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  waitForBlock(int seqid, TProtocol iprot, TProtocol oprot) async {
    WaitForBlock_args args = WaitForBlock_args();
    args.read(iprot);
    iprot.readMessageEnd();
    WaitForBlock_result result = WaitForBlock_result();
    result.success = await iface_.waitForBlock(args.obsolete);
    oprot.writeMessageBegin(new TMessage("WaitForBlock", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  waitForSmartTransaction(int seqid, TProtocol iprot, TProtocol oprot) async {
    WaitForSmartTransaction_args args = WaitForSmartTransaction_args();
    args.read(iprot);
    iprot.readMessageEnd();
    WaitForSmartTransaction_result result = WaitForSmartTransaction_result();
    result.success = await iface_.waitForSmartTransaction(args.smart_public);
    oprot.writeMessageBegin(new TMessage("WaitForSmartTransaction", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  smartContractsAllListGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    SmartContractsAllListGet_args args = SmartContractsAllListGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    SmartContractsAllListGet_result result = SmartContractsAllListGet_result();
    result.success = await iface_.smartContractsAllListGet(args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("SmartContractsAllListGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  transactionsStateGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TransactionsStateGet_args args = TransactionsStateGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TransactionsStateGet_result result = TransactionsStateGet_result();
    result.success = await iface_.transactionsStateGet(args.address, args.id);
    oprot.writeMessageBegin(new TMessage("TransactionsStateGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  contractAllMethodsGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    ContractAllMethodsGet_args args = ContractAllMethodsGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    ContractAllMethodsGet_result result = ContractAllMethodsGet_result();
    result.success = await iface_.contractAllMethodsGet(args.byteCodeObjects);
    oprot.writeMessageBegin(new TMessage("ContractAllMethodsGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  contractMethodsGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    ContractMethodsGet_args args = ContractMethodsGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    ContractMethodsGet_result result = ContractMethodsGet_result();
    result.success = await iface_.contractMethodsGet(args.address);
    oprot.writeMessageBegin(new TMessage("ContractMethodsGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  smartMethodParamsGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    SmartMethodParamsGet_args args = SmartMethodParamsGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    SmartMethodParamsGet_result result = SmartMethodParamsGet_result();
    result.success = await iface_.smartMethodParamsGet(args.address, args.id);
    oprot.writeMessageBegin(new TMessage("SmartMethodParamsGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  smartContractDataGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    SmartContractDataGet_args args = SmartContractDataGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    SmartContractDataGet_result result = SmartContractDataGet_result();
    result.success = await iface_.smartContractDataGet(args.address);
    oprot.writeMessageBegin(new TMessage("SmartContractDataGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  smartContractCompile(int seqid, TProtocol iprot, TProtocol oprot) async {
    SmartContractCompile_args args = SmartContractCompile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    SmartContractCompile_result result = SmartContractCompile_result();
    result.success = await iface_.smartContractCompile(args.sourceCode, args.lang);
    oprot.writeMessageBegin(new TMessage("SmartContractCompile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tokenBalancesGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TokenBalancesGet_args args = TokenBalancesGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TokenBalancesGet_result result = TokenBalancesGet_result();
    result.success = await iface_.tokenBalancesGet(args.address);
    oprot.writeMessageBegin(new TMessage("TokenBalancesGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tokenTransfersGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TokenTransfersGet_args args = TokenTransfersGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TokenTransfersGet_result result = TokenTransfersGet_result();
    result.success = await iface_.tokenTransfersGet(args.token, args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("TokenTransfersGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tokenTransferGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TokenTransferGet_args args = TokenTransferGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TokenTransferGet_result result = TokenTransferGet_result();
    result.success = await iface_.tokenTransferGet(args.token, args.id);
    oprot.writeMessageBegin(new TMessage("TokenTransferGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tokenTransfersListGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TokenTransfersListGet_args args = TokenTransfersListGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TokenTransfersListGet_result result = TokenTransfersListGet_result();
    result.success = await iface_.tokenTransfersListGet(args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("TokenTransfersListGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tokenWalletTransfersGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TokenWalletTransfersGet_args args = TokenWalletTransfersGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TokenWalletTransfersGet_result result = TokenWalletTransfersGet_result();
    result.success = await iface_.tokenWalletTransfersGet(args.token, args.address, args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("TokenWalletTransfersGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tokenTransactionsGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TokenTransactionsGet_args args = TokenTransactionsGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TokenTransactionsGet_result result = TokenTransactionsGet_result();
    result.success = await iface_.tokenTransactionsGet(args.token, args.offset, args.limit);
    oprot.writeMessageBegin(new TMessage("TokenTransactionsGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tokenInfoGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TokenInfoGet_args args = TokenInfoGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TokenInfoGet_result result = TokenInfoGet_result();
    result.success = await iface_.tokenInfoGet(args.token);
    oprot.writeMessageBegin(new TMessage("TokenInfoGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tokenHoldersGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TokenHoldersGet_args args = TokenHoldersGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TokenHoldersGet_result result = TokenHoldersGet_result();
    result.success = await iface_.tokenHoldersGet(args.token, args.offset, args.limit, args.order, args.desc);
    oprot.writeMessageBegin(new TMessage("TokenHoldersGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  tokensListGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TokensListGet_args args = TokensListGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TokensListGet_result result = TokensListGet_result();
    result.success = await iface_.tokensListGet(args.offset, args.limit, args.order, args.desc, args.filters);
    oprot.writeMessageBegin(new TMessage("TokensListGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  walletsGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    WalletsGet_args args = WalletsGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    WalletsGet_result result = WalletsGet_result();
    result.success = await iface_.walletsGet(args.offset, args.limit, args.ordCol, args.desc);
    oprot.writeMessageBegin(new TMessage("WalletsGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  trustedGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    TrustedGet_args args = TrustedGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    TrustedGet_result result = TrustedGet_result();
    result.success = await iface_.trustedGet(args.page);
    oprot.writeMessageBegin(new TMessage("TrustedGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  syncStateGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    SyncStateGet_args args = SyncStateGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    SyncStateGet_result result = SyncStateGet_result();
    result.success = await iface_.syncStateGet();
    oprot.writeMessageBegin(new TMessage("SyncStateGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  executeCountGet(int seqid, TProtocol iprot, TProtocol oprot) async {
    ExecuteCountGet_args args = ExecuteCountGet_args();
    args.read(iprot);
    iprot.readMessageEnd();
    ExecuteCountGet_result result = ExecuteCountGet_result();
    result.success = await iface_.executeCountGet(args.executeMethod);
    oprot.writeMessageBegin(new TMessage("ExecuteCountGet", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

}

class ActualFeeGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("ActualFeeGet_args");
  static final TField _TRANSACTION_SIZE_FIELD_DESC = TField("transactionSize", TType.I32, 1);

  int _transactionSize = 0;
  static const int TRANSACTIONSIZE = 1;


  ActualFeeGet_args() {
  }

  // transactionSize
  int get transactionSize => this._transactionSize;

  set transactionSize(int transactionSize) {
    this._transactionSize = transactionSize;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_transactionSize = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TRANSACTIONSIZE:
          if (field.type == TType.I32) {
            this.transactionSize = iprot.readI32();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TRANSACTION_SIZE_FIELD_DESC);
    oprot.writeI32(this.transactionSize);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("ActualFeeGet_args(");

    ret.write("transactionSize:");
    ret.write(this.transactionSize);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ActualFeeGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("ActualFeeGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  ActualFeeGetResult _success = ActualFeeGetResult();
  static const int SUCCESS = 0;


  ActualFeeGet_result() {
  }

  // success
  ActualFeeGetResult get success => this._success;

  set success(ActualFeeGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = ActualFeeGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("ActualFeeGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletDataGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletDataGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);

  Uint8List _address = "";
  static const int ADDRESS = 1;


  WalletDataGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletDataGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletDataGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletDataGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  WalletDataGetResult _success = WalletDataGetResult();
  static const int SUCCESS = 0;


  WalletDataGet_result() {
  }

  // success
  WalletDataGetResult get success => this._success;

  set success(WalletDataGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = WalletDataGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletDataGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletIdGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletIdGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);

  Uint8List _address = "";
  static const int ADDRESS = 1;


  WalletIdGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletIdGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletIdGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletIdGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  WalletIdGetResult _success = WalletIdGetResult();
  static const int SUCCESS = 0;


  WalletIdGet_result() {
  }

  // success
  WalletIdGetResult get success => this._success;

  set success(WalletIdGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = WalletIdGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletIdGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletTransactionsCountGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletTransactionsCountGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);

  Uint8List _address = "";
  static const int ADDRESS = 1;


  WalletTransactionsCountGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletTransactionsCountGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletTransactionsCountGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletTransactionsCountGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  WalletTransactionsCountGetResult _success = WalletTransactionsCountGetResult();
  static const int SUCCESS = 0;


  WalletTransactionsCountGet_result() {
  }

  // success
  WalletTransactionsCountGetResult get success => this._success;

  set success(WalletTransactionsCountGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = WalletTransactionsCountGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletTransactionsCountGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletBalanceGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletBalanceGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);

  Uint8List _address = "";
  static const int ADDRESS = 1;


  WalletBalanceGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletBalanceGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletBalanceGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletBalanceGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  WalletBalanceGetResult _success = WalletBalanceGetResult();
  static const int SUCCESS = 0;


  WalletBalanceGet_result() {
  }

  // success
  WalletBalanceGetResult get success => this._success;

  set success(WalletBalanceGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = WalletBalanceGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletBalanceGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class RoundDataGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("RoundDataGet_args");



  RoundDataGet_args() {
  }

  @override
  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("RoundDataGet_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class RoundDataGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("RoundDataGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  RoundData _success = RoundData();
  static const int SUCCESS = 0;


  RoundDataGet_result() {
  }

  // success
  RoundData get success => this._success;

  set success(RoundData success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = RoundData();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("RoundDataGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletsListBalancesGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletsListBalancesGet_args");
  static final TField _WALLET_ADDRESSES_FIELD_DESC = TField("walletAddresses", TType.STRUCT, 1);

  Addresses _walletAddresses = Addresses();
  static const int WALLETADDRESSES = 1;


  WalletsListBalancesGet_args() {
  }

  // walletAddresses
  Addresses get walletAddresses => this._walletAddresses;

  set walletAddresses(Addresses walletAddresses) {
    this._walletAddresses = walletAddresses;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_walletAddresses = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case WALLETADDRESSES:
          if (field.type == TType.STRUCT) {
            this.walletAddresses = Addresses();
            this.walletAddresses.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_WALLET_ADDRESSES_FIELD_DESC);
    this.walletAddresses.write(oprot);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletsListBalancesGet_args(");

    ret.write("walletAddresses:");
    ret.write(this.walletAddresses);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletsListBalancesGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletsListBalancesGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  AcceptedRequestId _success = AcceptedRequestId();
  static const int SUCCESS = 0;


  WalletsListBalancesGet_result() {
  }

  // success
  AcceptedRequestId get success => this._success;

  set success(AcceptedRequestId success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = AcceptedRequestId();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletsListBalancesGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletsListBalancesResultGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletsListBalancesResultGet_args");
  static final TField _REQUEST_ID_FIELD_DESC = TField("requestId", TType.I64, 1);

  int _requestId = 0;
  static const int REQUESTID = 1;


  WalletsListBalancesResultGet_args() {
  }

  // requestId
  int get requestId => this._requestId;

  set requestId(int requestId) {
    this._requestId = requestId;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_requestId = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUESTID:
          if (field.type == TType.I64) {
            this.requestId = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQUEST_ID_FIELD_DESC);
    oprot.writeI64(this.requestId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletsListBalancesResultGet_args(");

    ret.write("requestId:");
    ret.write(this.requestId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletsListBalancesResultGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletsListBalancesResultGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  WalletBalanceResults _success = WalletBalanceResults();
  static const int SUCCESS = 0;


  WalletsListBalancesResultGet_result() {
  }

  // success
  WalletBalanceResults get success => this._success;

  set success(WalletBalanceResults success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = WalletBalanceResults();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletsListBalancesResultGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionGet_args");
  static final TField _TRANSACTION_ID_FIELD_DESC = TField("transactionId", TType.STRUCT, 1);

  TransactionId _transactionId = TransactionId();
  static const int TRANSACTIONID = 1;


  TransactionGet_args() {
  }

  // transactionId
  TransactionId get transactionId => this._transactionId;

  set transactionId(TransactionId transactionId) {
    this._transactionId = transactionId;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_transactionId = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TRANSACTIONID:
          if (field.type == TType.STRUCT) {
            this.transactionId = TransactionId();
            this.transactionId.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TRANSACTION_ID_FIELD_DESC);
    this.transactionId.write(oprot);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionGet_args(");

    ret.write("transactionId:");
    ret.write(this.transactionId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TransactionGetResult _success = TransactionGetResult();
  static const int SUCCESS = 0;


  TransactionGet_result() {
  }

  // success
  TransactionGetResult get success => this._success;

  set success(TransactionGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TransactionGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 2);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 3);

  Uint8List _address = "";
  static const int ADDRESS = 1;
  int _offset = 0;
  static const int OFFSET = 2;
  int _limit = 0;
  static const int LIMIT = 3;


  TransactionsGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(", ");
    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TransactionsGetResult _success = TransactionsGetResult();
  static const int SUCCESS = 0;


  TransactionsGet_result() {
  }

  // success
  TransactionsGetResult get success => this._success;

  set success(TransactionsGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TransactionsGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionFlow_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionFlow_args");
  static final TField _TRANSACTION_FIELD_DESC = TField("transaction", TType.STRUCT, 1);

  Transaction _transaction = Transaction();
  static const int TRANSACTION = 1;


  TransactionFlow_args() {
  }

  // transaction
  Transaction get transaction => this._transaction;

  set transaction(Transaction transaction) {
    this._transaction = transaction;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_transaction = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TRANSACTION:
          if (field.type == TType.STRUCT) {
            this.transaction = Transaction();
            this.transaction.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TRANSACTION_FIELD_DESC);
    this.transaction.write(oprot);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionFlow_args(");

    ret.write("transaction:");
    ret.write(this.transaction);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionFlow_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionFlow_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TransactionFlowResult _success = TransactionFlowResult();
  static const int SUCCESS = 0;


  TransactionFlow_result() {
  }

  // success
  TransactionFlowResult get success => this._success;

  set success(TransactionFlowResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TransactionFlowResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionFlow_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsListGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsListGet_args");
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 1);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 2);

  int _offset = 0;
  static const int OFFSET = 1;
  int _limit = 0;
  static const int LIMIT = 2;


  TransactionsListGet_args() {
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsListGet_args(");

    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsListGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsListGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TransactionsGetResult _success = TransactionsGetResult();
  static const int SUCCESS = 0;


  TransactionsListGet_result() {
  }

  // success
  TransactionsGetResult get success => this._success;

  set success(TransactionsGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TransactionsGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsListGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class FilteredTransactionsListGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("FilteredTransactionsListGet_args");
  static final TField _GENERAL_QUERY_FIELD_DESC = TField("generalQuery", TType.STRUCT, 1);

  TransactionsQuery _generalQuery = TransactionsQuery();
  static const int GENERALQUERY = 1;


  FilteredTransactionsListGet_args() {
  }

  // generalQuery
  TransactionsQuery get generalQuery => this._generalQuery;

  set generalQuery(TransactionsQuery generalQuery) {
    this._generalQuery = generalQuery;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_generalQuery = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GENERALQUERY:
          if (field.type == TType.STRUCT) {
            this.generalQuery = TransactionsQuery();
            this.generalQuery.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_GENERAL_QUERY_FIELD_DESC);
    this.generalQuery.write(oprot);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("FilteredTransactionsListGet_args(");

    ret.write("generalQuery:");
    ret.write(this.generalQuery);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class FilteredTransactionsListGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("FilteredTransactionsListGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  FilteredTransactionsListResult _success = FilteredTransactionsListResult();
  static const int SUCCESS = 0;


  FilteredTransactionsListGet_result() {
  }

  // success
  FilteredTransactionsListResult get success => this._success;

  set success(FilteredTransactionsListResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = FilteredTransactionsListResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("FilteredTransactionsListGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class FilteredTrxsListGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("FilteredTrxsListGet_args");
  static final TField _GENERAL_QUERY_FIELD_DESC = TField("generalQuery", TType.STRUCT, 1);

  TransactionsQuery _generalQuery = TransactionsQuery();
  static const int GENERALQUERY = 1;


  FilteredTrxsListGet_args() {
  }

  // generalQuery
  TransactionsQuery get generalQuery => this._generalQuery;

  set generalQuery(TransactionsQuery generalQuery) {
    this._generalQuery = generalQuery;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_generalQuery = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case GENERALQUERY:
          if (field.type == TType.STRUCT) {
            this.generalQuery = TransactionsQuery();
            this.generalQuery.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_GENERAL_QUERY_FIELD_DESC);
    this.generalQuery.write(oprot);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("FilteredTrxsListGet_args(");

    ret.write("generalQuery:");
    ret.write(this.generalQuery);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class FilteredTrxsListGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("FilteredTrxsListGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  AcceptedRequestId _success = AcceptedRequestId();
  static const int SUCCESS = 0;


  FilteredTrxsListGet_result() {
  }

  // success
  AcceptedRequestId get success => this._success;

  set success(AcceptedRequestId success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = AcceptedRequestId();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("FilteredTrxsListGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class FilteredTrxsListGetResult_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("FilteredTrxsListGetResult_args");
  static final TField _REQUEST_ID_FIELD_DESC = TField("requestId", TType.I64, 1);

  int _requestId = 0;
  static const int REQUESTID = 1;


  FilteredTrxsListGetResult_args() {
  }

  // requestId
  int get requestId => this._requestId;

  set requestId(int requestId) {
    this._requestId = requestId;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_requestId = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUESTID:
          if (field.type == TType.I64) {
            this.requestId = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQUEST_ID_FIELD_DESC);
    oprot.writeI64(this.requestId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("FilteredTrxsListGetResult_args(");

    ret.write("requestId:");
    ret.write(this.requestId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class FilteredTrxsListGetResult_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("FilteredTrxsListGetResult_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  FilteredTransactionsListResult _success = FilteredTransactionsListResult();
  static const int SUCCESS = 0;


  FilteredTrxsListGetResult_result() {
  }

  // success
  FilteredTransactionsListResult get success => this._success;

  set success(FilteredTransactionsListResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = FilteredTransactionsListResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("FilteredTrxsListGetResult_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionSend_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionSend_args");
  static final TField _TRANSACTION_FIELD_DESC = TField("transaction", TType.STRUCT, 1);

  Transaction _transaction = Transaction();
  static const int TRANSACTION = 1;


  TransactionSend_args() {
  }

  // transaction
  Transaction get transaction => this._transaction;

  set transaction(Transaction transaction) {
    this._transaction = transaction;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_transaction = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TRANSACTION:
          if (field.type == TType.STRUCT) {
            this.transaction = Transaction();
            this.transaction.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TRANSACTION_FIELD_DESC);
    this.transaction.write(oprot);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionSend_args(");

    ret.write("transaction:");
    ret.write(this.transaction);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionSend_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionSend_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SendTransactionResult _success = SendTransactionResult();
  static const int SUCCESS = 0;


  TransactionSend_result() {
  }

  // success
  SendTransactionResult get success => this._success;

  set success(SendTransactionResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SendTransactionResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionSend_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionResultGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionResultGet_args");
  static final TField _REQUEST_ID_FIELD_DESC = TField("requestId", TType.I64, 1);

  int _requestId = 0;
  static const int REQUESTID = 1;


  TransactionResultGet_args() {
  }

  // requestId
  int get requestId => this._requestId;

  set requestId(int requestId) {
    this._requestId = requestId;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_requestId = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUESTID:
          if (field.type == TType.I64) {
            this.requestId = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQUEST_ID_FIELD_DESC);
    oprot.writeI64(this.requestId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionResultGet_args(");

    ret.write("requestId:");
    ret.write(this.requestId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionResultGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionResultGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TransactionFlowResult _success = TransactionFlowResult();
  static const int SUCCESS = 0;


  TransactionResultGet_result() {
  }

  // success
  TransactionFlowResult get success => this._success;

  set success(TransactionFlowResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TransactionFlowResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionResultGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsListSend_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsListSend_args");
  static final TField _TRANSACTIONS_FIELD_DESC = TField("transactions", TType.STRUCT, 1);

  TransactionsList _transactions = TransactionsList();
  static const int TRANSACTIONS = 1;


  TransactionsListSend_args() {
  }

  // transactions
  TransactionsList get transactions => this._transactions;

  set transactions(TransactionsList transactions) {
    this._transactions = transactions;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_transactions = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TRANSACTIONS:
          if (field.type == TType.STRUCT) {
            this.transactions = TransactionsList();
            this.transactions.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TRANSACTIONS_FIELD_DESC);
    this.transactions.write(oprot);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsListSend_args(");

    ret.write("transactions:");
    ret.write(this.transactions);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsListSend_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsListSend_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SendTransactionResult _success = SendTransactionResult();
  static const int SUCCESS = 0;


  TransactionsListSend_result() {
  }

  // success
  SendTransactionResult get success => this._success;

  set success(SendTransactionResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SendTransactionResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsListSend_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsListResultGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsListResultGet_args");
  static final TField _REQUEST_ID_FIELD_DESC = TField("requestId", TType.I64, 1);

  int _requestId = 0;
  static const int REQUESTID = 1;


  TransactionsListResultGet_args() {
  }

  // requestId
  int get requestId => this._requestId;

  set requestId(int requestId) {
    this._requestId = requestId;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_requestId = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQUESTID:
          if (field.type == TType.I64) {
            this.requestId = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_REQUEST_ID_FIELD_DESC);
    oprot.writeI64(this.requestId);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsListResultGet_args(");

    ret.write("requestId:");
    ret.write(this.requestId);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsListResultGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsListResultGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TransactionsListFlowResult _success = TransactionsListFlowResult();
  static const int SUCCESS = 0;


  TransactionsListResultGet_result() {
  }

  // success
  TransactionsListFlowResult get success => this._success;

  set success(TransactionsListFlowResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TransactionsListFlowResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsListResultGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetLastHash_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("GetLastHash_args");



  GetLastHash_args() {
  }

  @override
  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("GetLastHash_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetLastHash_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("GetLastHash_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRING, 0);

  Uint8List _success = "";
  static const int SUCCESS = 0;


  GetLastHash_result() {
  }

  // success
  Uint8List get success => this._success;

  set success(Uint8List success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("GetLastHash_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class PoolListGetStable_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("PoolListGetStable_args");
  static final TField _SEQUENCE_FIELD_DESC = TField("sequence", TType.I64, 1);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 2);

  int _sequence = 0;
  static const int SEQUENCE = 1;
  int _limit = 0;
  static const int LIMIT = 2;


  PoolListGetStable_args() {
  }

  // sequence
  int get sequence => this._sequence;

  set sequence(int sequence) {
    this._sequence = sequence;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_sequence = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQUENCE:
          if (field.type == TType.I64) {
            this.sequence = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQUENCE_FIELD_DESC);
    oprot.writeI64(this.sequence);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("PoolListGetStable_args(");

    ret.write("sequence:");
    ret.write(this.sequence);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class PoolListGetStable_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("PoolListGetStable_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  PoolListGetResult _success = PoolListGetResult();
  static const int SUCCESS = 0;


  PoolListGetStable_result() {
  }

  // success
  PoolListGetResult get success => this._success;

  set success(PoolListGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = PoolListGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("PoolListGetStable_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class PoolListGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("PoolListGet_args");
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 1);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 2);

  int _offset = 0;
  static const int OFFSET = 1;
  int _limit = 0;
  static const int LIMIT = 2;


  PoolListGet_args() {
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("PoolListGet_args(");

    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class PoolListGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("PoolListGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  PoolListGetResult _success = PoolListGetResult();
  static const int SUCCESS = 0;


  PoolListGet_result() {
  }

  // success
  PoolListGetResult get success => this._success;

  set success(PoolListGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = PoolListGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("PoolListGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class PoolInfoGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("PoolInfoGet_args");
  static final TField _SEQUENCE_FIELD_DESC = TField("sequence", TType.I64, 1);
  static final TField _INDEX_FIELD_DESC = TField("index", TType.I64, 2);

  int _sequence = 0;
  static const int SEQUENCE = 1;
  int _index = 0;
  static const int INDEX = 2;


  PoolInfoGet_args() {
  }

  // sequence
  int get sequence => this._sequence;

  set sequence(int sequence) {
    this._sequence = sequence;
  }

  // index
  int get index => this._index;

  set index(int index) {
    this._index = index;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_sequence = false;
    bool __isset_index = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQUENCE:
          if (field.type == TType.I64) {
            this.sequence = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case INDEX:
          if (field.type == TType.I64) {
            this.index = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQUENCE_FIELD_DESC);
    oprot.writeI64(this.sequence);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_INDEX_FIELD_DESC);
    oprot.writeI64(this.index);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("PoolInfoGet_args(");

    ret.write("sequence:");
    ret.write(this.sequence);

    ret.write(", ");
    ret.write("index:");
    ret.write(this.index);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class PoolInfoGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("PoolInfoGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  PoolInfoGetResult _success = PoolInfoGetResult();
  static const int SUCCESS = 0;


  PoolInfoGet_result() {
  }

  // success
  PoolInfoGetResult get success => this._success;

  set success(PoolInfoGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = PoolInfoGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("PoolInfoGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class PoolTransactionsGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("PoolTransactionsGet_args");
  static final TField _SEQUENCE_FIELD_DESC = TField("sequence", TType.I64, 1);
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 2);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 3);

  int _sequence = 0;
  static const int SEQUENCE = 1;
  int _offset = 0;
  static const int OFFSET = 2;
  int _limit = 0;
  static const int LIMIT = 3;


  PoolTransactionsGet_args() {
  }

  // sequence
  int get sequence => this._sequence;

  set sequence(int sequence) {
    this._sequence = sequence;
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_sequence = false;
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SEQUENCE:
          if (field.type == TType.I64) {
            this.sequence = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SEQUENCE_FIELD_DESC);
    oprot.writeI64(this.sequence);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("PoolTransactionsGet_args(");

    ret.write("sequence:");
    ret.write(this.sequence);

    ret.write(", ");
    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class PoolTransactionsGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("PoolTransactionsGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  PoolTransactionsGetResult _success = PoolTransactionsGetResult();
  static const int SUCCESS = 0;


  PoolTransactionsGet_result() {
  }

  // success
  PoolTransactionsGetResult get success => this._success;

  set success(PoolTransactionsGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = PoolTransactionsGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("PoolTransactionsGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class StatsGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("StatsGet_args");



  StatsGet_args() {
  }

  @override
  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("StatsGet_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class StatsGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("StatsGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  StatsGetResult _success = StatsGetResult();
  static const int SUCCESS = 0;


  StatsGet_result() {
  }

  // success
  StatsGetResult get success => this._success;

  set success(StatsGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = StatsGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("StatsGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);

  Uint8List _address = "";
  static const int ADDRESS = 1;


  SmartContractGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SmartContractGetResult _success = SmartContractGetResult();
  static const int SUCCESS = 0;


  SmartContractGet_result() {
  }

  // success
  SmartContractGetResult get success => this._success;

  set success(SmartContractGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SmartContractGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractsListGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractsListGet_args");
  static final TField _DEPLOYER_FIELD_DESC = TField("deployer", TType.STRING, 1);
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 2);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 3);

  Uint8List _deployer = "";
  static const int DEPLOYER = 1;
  int _offset = 0;
  static const int OFFSET = 2;
  int _limit = 0;
  static const int LIMIT = 3;


  SmartContractsListGet_args() {
  }

  // deployer
  Uint8List get deployer => this._deployer;

  set deployer(Uint8List deployer) {
    this._deployer = deployer;
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_deployer = false;
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case DEPLOYER:
          if (field.type == TType.STRING) {
            this.deployer = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_DEPLOYER_FIELD_DESC);
    oprot.writeBinary(this.deployer);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractsListGet_args(");

    ret.write("deployer:");
    ret.write(this.deployer);

    ret.write(", ");
    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractsListGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractsListGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SmartContractsListGetResult _success = SmartContractsListGetResult();
  static const int SUCCESS = 0;


  SmartContractsListGet_result() {
  }

  // success
  SmartContractsListGetResult get success => this._success;

  set success(SmartContractsListGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SmartContractsListGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractsListGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractAddressesListGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractAddressesListGet_args");
  static final TField _DEPLOYER_FIELD_DESC = TField("deployer", TType.STRING, 1);

  Uint8List _deployer = "";
  static const int DEPLOYER = 1;


  SmartContractAddressesListGet_args() {
  }

  // deployer
  Uint8List get deployer => this._deployer;

  set deployer(Uint8List deployer) {
    this._deployer = deployer;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_deployer = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case DEPLOYER:
          if (field.type == TType.STRING) {
            this.deployer = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_DEPLOYER_FIELD_DESC);
    oprot.writeBinary(this.deployer);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractAddressesListGet_args(");

    ret.write("deployer:");
    ret.write(this.deployer);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractAddressesListGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractAddressesListGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SmartContractAddressesListGetResult _success = SmartContractAddressesListGetResult();
  static const int SUCCESS = 0;


  SmartContractAddressesListGet_result() {
  }

  // success
  SmartContractAddressesListGetResult get success => this._success;

  set success(SmartContractAddressesListGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SmartContractAddressesListGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractAddressesListGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WaitForBlock_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WaitForBlock_args");
  static final TField _OBSOLETE_FIELD_DESC = TField("obsolete", TType.STRING, 1);

  Uint8List _obsolete = "";
  static const int OBSOLETE = 1;


  WaitForBlock_args() {
  }

  // obsolete
  Uint8List get obsolete => this._obsolete;

  set obsolete(Uint8List obsolete) {
    this._obsolete = obsolete;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_obsolete = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case OBSOLETE:
          if (field.type == TType.STRING) {
            this.obsolete = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_OBSOLETE_FIELD_DESC);
    oprot.writeBinary(this.obsolete);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WaitForBlock_args(");

    ret.write("obsolete:");
    ret.write(this.obsolete);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WaitForBlock_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WaitForBlock_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRING, 0);

  Uint8List _success = "";
  static const int SUCCESS = 0;


  WaitForBlock_result() {
  }

  // success
  Uint8List get success => this._success;

  set success(Uint8List success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WaitForBlock_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WaitForSmartTransaction_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WaitForSmartTransaction_args");
  static final TField _SMART_PUBLIC_FIELD_DESC = TField("smart_public", TType.STRING, 1);

  Uint8List _smart_public = "";
  static const int SMART_PUBLIC = 1;


  WaitForSmartTransaction_args() {
  }

  // smart_public
  Uint8List get smart_public => this._smart_public;

  set smart_public(Uint8List smart_public) {
    this._smart_public = smart_public;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_smart_public = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SMART_PUBLIC:
          if (field.type == TType.STRING) {
            this.smart_public = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SMART_PUBLIC_FIELD_DESC);
    oprot.writeBinary(this.smart_public);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WaitForSmartTransaction_args(");

    ret.write("smart_public:");
    ret.write(this.smart_public);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WaitForSmartTransaction_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WaitForSmartTransaction_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TransactionId _success = TransactionId();
  static const int SUCCESS = 0;


  WaitForSmartTransaction_result() {
  }

  // success
  TransactionId get success => this._success;

  set success(TransactionId success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TransactionId();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WaitForSmartTransaction_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractsAllListGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractsAllListGet_args");
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 1);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 2);

  int _offset = 0;
  static const int OFFSET = 1;
  int _limit = 0;
  static const int LIMIT = 2;


  SmartContractsAllListGet_args() {
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractsAllListGet_args(");

    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractsAllListGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractsAllListGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SmartContractsListGetResult _success = SmartContractsListGetResult();
  static const int SUCCESS = 0;


  SmartContractsAllListGet_result() {
  }

  // success
  SmartContractsListGetResult get success => this._success;

  set success(SmartContractsListGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SmartContractsListGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractsAllListGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsStateGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsStateGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);
  static final TField _ID_FIELD_DESC = TField("id", TType.LIST, 2);

  Uint8List _address = "";
  static const int ADDRESS = 1;
  List<int> _id = [];
  static const int ID = 2;


  TransactionsStateGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  // id
  List<int> get id => this._id;

  set id(List<int> id) {
    this._id = id;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    bool __isset_id = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ID:
          if (field.type == TType.LIST) {
            {
              TList _list190 = iprot.readListBegin();
              this.id = [];
              for (int _i191 = 0; _i191 < _list190.length; ++_i191) {
                int _elem192;//declare element for this.id
                _elem192 = iprot.readI64();
                this.id.add(_elem192);//add element to parent this.id
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ID_FIELD_DESC);
    {
      oprot.writeListBegin(TList(TType.I64, this.id.length));
      for (var elem193 in this.id) {
        oprot.writeI64(elem193);
      }
      oprot.writeListEnd();
    }
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsStateGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(", ");
    ret.write("id:");
    ret.write(this.id);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TransactionsStateGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TransactionsStateGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TransactionsStateGetResult _success = TransactionsStateGetResult();
  static const int SUCCESS = 0;


  TransactionsStateGet_result() {
  }

  // success
  TransactionsStateGetResult get success => this._success;

  set success(TransactionsStateGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TransactionsStateGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TransactionsStateGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ContractAllMethodsGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("ContractAllMethodsGet_args");
  static final TField _BYTE_CODE_OBJECTS_FIELD_DESC = TField("byteCodeObjects", TType.LIST, 1);

  List<t_general.ByteCodeObject> _byteCodeObjects = [];
  static const int BYTECODEOBJECTS = 1;


  ContractAllMethodsGet_args() {
  }

  // byteCodeObjects
  List<t_general.ByteCodeObject> get byteCodeObjects => this._byteCodeObjects;

  set byteCodeObjects(List<t_general.ByteCodeObject> byteCodeObjects) {
    this._byteCodeObjects = byteCodeObjects;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_byteCodeObjects = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case BYTECODEOBJECTS:
          if (field.type == TType.LIST) {
            {
              TList _list194 = iprot.readListBegin();
              this.byteCodeObjects = [];
              for (int _i195 = 0; _i195 < _list194.length; ++_i195) {
                t_general.ByteCodeObject _elem196;//declare element for this.byteCodeObjects
                _elem196 = t_general.ByteCodeObject();
                _elem196.read(iprot);
                this.byteCodeObjects.add(_elem196);//add element to parent this.byteCodeObjects
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_BYTE_CODE_OBJECTS_FIELD_DESC);
    {
      oprot.writeListBegin(TList(TType.STRUCT, this.byteCodeObjects.length));
      for (var elem197 in this.byteCodeObjects) {
        elem197.write(oprot);
      }
      oprot.writeListEnd();
    }
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("ContractAllMethodsGet_args(");

    ret.write("byteCodeObjects:");
    ret.write(this.byteCodeObjects);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ContractAllMethodsGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("ContractAllMethodsGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  ContractAllMethodsGetResult _success = ContractAllMethodsGetResult();
  static const int SUCCESS = 0;


  ContractAllMethodsGet_result() {
  }

  // success
  ContractAllMethodsGetResult get success => this._success;

  set success(ContractAllMethodsGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = ContractAllMethodsGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("ContractAllMethodsGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ContractMethodsGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("ContractMethodsGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);

  Uint8List _address = "";
  static const int ADDRESS = 1;


  ContractMethodsGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("ContractMethodsGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ContractMethodsGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("ContractMethodsGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  ContractAllMethodsGetResult _success = ContractAllMethodsGetResult();
  static const int SUCCESS = 0;


  ContractMethodsGet_result() {
  }

  // success
  ContractAllMethodsGetResult get success => this._success;

  set success(ContractAllMethodsGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = ContractAllMethodsGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("ContractMethodsGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartMethodParamsGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartMethodParamsGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);
  static final TField _ID_FIELD_DESC = TField("id", TType.I64, 2);

  Uint8List _address = "";
  static const int ADDRESS = 1;
  int _id = 0;
  static const int ID = 2;


  SmartMethodParamsGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  // id
  int get id => this._id;

  set id(int id) {
    this._id = id;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    bool __isset_id = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ID:
          if (field.type == TType.I64) {
            this.id = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ID_FIELD_DESC);
    oprot.writeI64(this.id);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartMethodParamsGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(", ");
    ret.write("id:");
    ret.write(this.id);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartMethodParamsGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartMethodParamsGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SmartMethodParamsGetResult _success = SmartMethodParamsGetResult();
  static const int SUCCESS = 0;


  SmartMethodParamsGet_result() {
  }

  // success
  SmartMethodParamsGetResult get success => this._success;

  set success(SmartMethodParamsGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SmartMethodParamsGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartMethodParamsGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractDataGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractDataGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);

  Uint8List _address = "";
  static const int ADDRESS = 1;


  SmartContractDataGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractDataGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractDataGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractDataGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SmartContractDataResult _success = SmartContractDataResult();
  static const int SUCCESS = 0;


  SmartContractDataGet_result() {
  }

  // success
  SmartContractDataResult get success => this._success;

  set success(SmartContractDataResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SmartContractDataResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractDataGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractCompile_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractCompile_args");
  static final TField _SOURCE_CODE_FIELD_DESC = TField("sourceCode", TType.STRING, 1);
  static final TField _LANG_FIELD_DESC = TField("lang", TType.BYTE, 2);

  String _sourceCode = "";
  static const int SOURCECODE = 1;
  int _lang = 0;
  static const int LANG = 2;


  SmartContractCompile_args() {
  }

  // sourceCode
  String get sourceCode => this._sourceCode;

  set sourceCode(String sourceCode) {
    this._sourceCode = sourceCode;
  }

  // lang
  int get lang => this._lang;

  set lang(int lang) {
    this._lang = lang;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_sourceCode = false;
    bool __isset_lang = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SOURCECODE:
          if (field.type == TType.STRING) {
            this.sourceCode = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LANG:
          if (field.type == TType.BYTE) {
            this.lang = iprot.readByte();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_SOURCE_CODE_FIELD_DESC);
    oprot.writeString(this.sourceCode);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LANG_FIELD_DESC);
    oprot.writeByte(this.lang);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractCompile_args(");

    ret.write("sourceCode:");
    ret.write(this.sourceCode);

    ret.write(", ");
    ret.write("lang:");
    ret.write(this.lang);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SmartContractCompile_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SmartContractCompile_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SmartContractCompileResult _success = SmartContractCompileResult();
  static const int SUCCESS = 0;


  SmartContractCompile_result() {
  }

  // success
  SmartContractCompileResult get success => this._success;

  set success(SmartContractCompileResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SmartContractCompileResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SmartContractCompile_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenBalancesGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenBalancesGet_args");
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 1);

  Uint8List _address = "";
  static const int ADDRESS = 1;


  TokenBalancesGet_args() {
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_address = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenBalancesGet_args(");

    ret.write("address:");
    ret.write(this.address);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenBalancesGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenBalancesGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TokenBalancesResult _success = TokenBalancesResult();
  static const int SUCCESS = 0;


  TokenBalancesGet_result() {
  }

  // success
  TokenBalancesResult get success => this._success;

  set success(TokenBalancesResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TokenBalancesResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenBalancesGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenTransfersGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenTransfersGet_args");
  static final TField _TOKEN_FIELD_DESC = TField("token", TType.STRING, 1);
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 2);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 3);

  Uint8List _token = "";
  static const int TOKEN = 1;
  int _offset = 0;
  static const int OFFSET = 2;
  int _limit = 0;
  static const int LIMIT = 3;


  TokenTransfersGet_args() {
  }

  // token
  Uint8List get token => this._token;

  set token(Uint8List token) {
    this._token = token;
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_token = false;
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TOKEN:
          if (field.type == TType.STRING) {
            this.token = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TOKEN_FIELD_DESC);
    oprot.writeBinary(this.token);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenTransfersGet_args(");

    ret.write("token:");
    ret.write(this.token);

    ret.write(", ");
    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenTransfersGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenTransfersGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TokenTransfersResult _success = TokenTransfersResult();
  static const int SUCCESS = 0;


  TokenTransfersGet_result() {
  }

  // success
  TokenTransfersResult get success => this._success;

  set success(TokenTransfersResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TokenTransfersResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenTransfersGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenTransferGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenTransferGet_args");
  static final TField _TOKEN_FIELD_DESC = TField("token", TType.STRING, 1);
  static final TField _ID_FIELD_DESC = TField("id", TType.STRUCT, 2);

  Uint8List _token = "";
  static const int TOKEN = 1;
  TransactionId _id = TransactionId();
  static const int ID = 2;


  TokenTransferGet_args() {
  }

  // token
  Uint8List get token => this._token;

  set token(Uint8List token) {
    this._token = token;
  }

  // id
  TransactionId get id => this._id;

  set id(TransactionId id) {
    this._id = id;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_token = false;
    bool __isset_id = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TOKEN:
          if (field.type == TType.STRING) {
            this.token = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = TransactionId();
            this.id.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TOKEN_FIELD_DESC);
    oprot.writeBinary(this.token);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ID_FIELD_DESC);
    this.id.write(oprot);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenTransferGet_args(");

    ret.write("token:");
    ret.write(this.token);

    ret.write(", ");
    ret.write("id:");
    ret.write(this.id);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenTransferGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenTransferGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TokenTransfersResult _success = TokenTransfersResult();
  static const int SUCCESS = 0;


  TokenTransferGet_result() {
  }

  // success
  TokenTransfersResult get success => this._success;

  set success(TokenTransfersResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TokenTransfersResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenTransferGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenTransfersListGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenTransfersListGet_args");
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 1);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 2);

  int _offset = 0;
  static const int OFFSET = 1;
  int _limit = 0;
  static const int LIMIT = 2;


  TokenTransfersListGet_args() {
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenTransfersListGet_args(");

    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenTransfersListGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenTransfersListGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TokenTransfersResult _success = TokenTransfersResult();
  static const int SUCCESS = 0;


  TokenTransfersListGet_result() {
  }

  // success
  TokenTransfersResult get success => this._success;

  set success(TokenTransfersResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TokenTransfersResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenTransfersListGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenWalletTransfersGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenWalletTransfersGet_args");
  static final TField _TOKEN_FIELD_DESC = TField("token", TType.STRING, 1);
  static final TField _ADDRESS_FIELD_DESC = TField("address", TType.STRING, 2);
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 3);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 4);

  Uint8List _token = "";
  static const int TOKEN = 1;
  Uint8List _address = "";
  static const int ADDRESS = 2;
  int _offset = 0;
  static const int OFFSET = 3;
  int _limit = 0;
  static const int LIMIT = 4;


  TokenWalletTransfersGet_args() {
  }

  // token
  Uint8List get token => this._token;

  set token(Uint8List token) {
    this._token = token;
  }

  // address
  Uint8List get address => this._address;

  set address(Uint8List address) {
    this._address = address;
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_token = false;
    bool __isset_address = false;
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TOKEN:
          if (field.type == TType.STRING) {
            this.token = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ADDRESS:
          if (field.type == TType.STRING) {
            this.address = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TOKEN_FIELD_DESC);
    oprot.writeBinary(this.token);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ADDRESS_FIELD_DESC);
    oprot.writeBinary(this.address);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenWalletTransfersGet_args(");

    ret.write("token:");
    ret.write(this.token);

    ret.write(", ");
    ret.write("address:");
    ret.write(this.address);

    ret.write(", ");
    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenWalletTransfersGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenWalletTransfersGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TokenTransfersResult _success = TokenTransfersResult();
  static const int SUCCESS = 0;


  TokenWalletTransfersGet_result() {
  }

  // success
  TokenTransfersResult get success => this._success;

  set success(TokenTransfersResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TokenTransfersResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenWalletTransfersGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenTransactionsGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenTransactionsGet_args");
  static final TField _TOKEN_FIELD_DESC = TField("token", TType.STRING, 1);
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 2);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 3);

  Uint8List _token = "";
  static const int TOKEN = 1;
  int _offset = 0;
  static const int OFFSET = 2;
  int _limit = 0;
  static const int LIMIT = 3;


  TokenTransactionsGet_args() {
  }

  // token
  Uint8List get token => this._token;

  set token(Uint8List token) {
    this._token = token;
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_token = false;
    bool __isset_offset = false;
    bool __isset_limit = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TOKEN:
          if (field.type == TType.STRING) {
            this.token = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TOKEN_FIELD_DESC);
    oprot.writeBinary(this.token);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenTransactionsGet_args(");

    ret.write("token:");
    ret.write(this.token);

    ret.write(", ");
    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenTransactionsGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenTransactionsGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TokenTransactionsResult _success = TokenTransactionsResult();
  static const int SUCCESS = 0;


  TokenTransactionsGet_result() {
  }

  // success
  TokenTransactionsResult get success => this._success;

  set success(TokenTransactionsResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TokenTransactionsResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenTransactionsGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenInfoGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenInfoGet_args");
  static final TField _TOKEN_FIELD_DESC = TField("token", TType.STRING, 1);

  Uint8List _token = "";
  static const int TOKEN = 1;


  TokenInfoGet_args() {
  }

  // token
  Uint8List get token => this._token;

  set token(Uint8List token) {
    this._token = token;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_token = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TOKEN:
          if (field.type == TType.STRING) {
            this.token = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TOKEN_FIELD_DESC);
    oprot.writeBinary(this.token);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenInfoGet_args(");

    ret.write("token:");
    ret.write(this.token);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenInfoGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenInfoGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TokenInfoResult _success = TokenInfoResult();
  static const int SUCCESS = 0;


  TokenInfoGet_result() {
  }

  // success
  TokenInfoResult get success => this._success;

  set success(TokenInfoResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TokenInfoResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenInfoGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokenHoldersGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenHoldersGet_args");
  static final TField _TOKEN_FIELD_DESC = TField("token", TType.STRING, 1);
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 2);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 3);
  static final TField _ORDER_FIELD_DESC = TField("order", TType.I32, 4);
  static final TField _DESC_FIELD_DESC = TField("desc", TType.BOOL, 5);

  Uint8List _token = "";
  static const int TOKEN = 1;
  int _offset = 0;
  static const int OFFSET = 2;
  int _limit = 0;
  static const int LIMIT = 3;
  int _order = 0;
  static const int ORDER = 4;
  bool _desc = false;
  static const int DESC = 5;


  TokenHoldersGet_args() {
  }

  // token
  Uint8List get token => this._token;

  set token(Uint8List token) {
    this._token = token;
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  // order
  int get order => this._order;

  set order(int order) {
    this._order = order;
  }

  // desc
  bool get desc => this._desc;

  set desc(bool desc) {
    this._desc = desc;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_token = false;
    bool __isset_offset = false;
    bool __isset_limit = false;
    bool __isset_order = false;
    bool __isset_desc = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case TOKEN:
          if (field.type == TType.STRING) {
            this.token = iprot.readBinary();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ORDER:
          if (field.type == TType.I32) {
            this.order = iprot.readI32();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DESC:
          if (field.type == TType.BOOL) {
            this.desc = iprot.readBool();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_TOKEN_FIELD_DESC);
    oprot.writeBinary(this.token);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ORDER_FIELD_DESC);
    oprot.writeI32(this.order);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_DESC_FIELD_DESC);
    oprot.writeBool(this.desc);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenHoldersGet_args(");

    ret.write("token:");
    ret.write(this.token);

    ret.write(", ");
    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(", ");
    ret.write("order:");
    String order_name = TokenHoldersSortField.VALUES_TO_NAMES[this.order]!;
    if (order_name != null) {
      ret.write(order_name);
      ret.write(" (");
    }
    ret.write(this.order);
    if (order_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("desc:");
    ret.write(this.desc);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetOrder() && !TokenHoldersSortField.VALID_VALUES.contains(order)) {
      throw TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'order' has been assigned the invalid value $order");
    }
  }

}

class TokenHoldersGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokenHoldersGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TokenHoldersResult _success = TokenHoldersResult();
  static const int SUCCESS = 0;


  TokenHoldersGet_result() {
  }

  // success
  TokenHoldersResult get success => this._success;

  set success(TokenHoldersResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TokenHoldersResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokenHoldersGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TokensListGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokensListGet_args");
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 1);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 2);
  static final TField _ORDER_FIELD_DESC = TField("order", TType.I32, 3);
  static final TField _DESC_FIELD_DESC = TField("desc", TType.BOOL, 4);
  static final TField _FILTERS_FIELD_DESC = TField("filters", TType.STRUCT, 5);

  int _offset = 0;
  static const int OFFSET = 1;
  int _limit = 0;
  static const int LIMIT = 2;
  int _order = 0;
  static const int ORDER = 3;
  bool _desc = false;
  static const int DESC = 4;
  TokenFilters _filters = TokenFilters();
  static const int FILTERS = 5;


  TokensListGet_args() {
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  // order
  int get order => this._order;

  set order(int order) {
    this._order = order;
  }

  // desc
  bool get desc => this._desc;

  set desc(bool desc) {
    this._desc = desc;
  }

  // filters
  TokenFilters get filters => this._filters;

  set filters(TokenFilters filters) {
    this._filters = filters;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_offset = false;
    bool __isset_limit = false;
    bool __isset_order = false;
    bool __isset_desc = false;
    bool __isset_filters = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ORDER:
          if (field.type == TType.I32) {
            this.order = iprot.readI32();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DESC:
          if (field.type == TType.BOOL) {
            this.desc = iprot.readBool();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FILTERS:
          if (field.type == TType.STRUCT) {
            this.filters = TokenFilters();
            this.filters.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ORDER_FIELD_DESC);
    oprot.writeI32(this.order);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_DESC_FIELD_DESC);
    oprot.writeBool(this.desc);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_FILTERS_FIELD_DESC);
    this.filters.write(oprot);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokensListGet_args(");

    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(", ");
    ret.write("order:");
    String order_name = TokensListSortField.VALUES_TO_NAMES[this.order]!;
    if (order_name != null) {
      ret.write(order_name);
      ret.write(" (");
    }
    ret.write(this.order);
    if (order_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("desc:");
    ret.write(this.desc);

    ret.write(", ");
    ret.write("filters:");
    ret.write(this.filters);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetOrder() && !TokensListSortField.VALID_VALUES.contains(order)) {
      throw TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'order' has been assigned the invalid value $order");
    }
  }

}

class TokensListGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TokensListGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TokensListResult _success = TokensListResult();
  static const int SUCCESS = 0;


  TokensListGet_result() {
  }

  // success
  TokensListResult get success => this._success;

  set success(TokensListResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TokensListResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TokensListGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletsGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletsGet_args");
  static final TField _OFFSET_FIELD_DESC = TField("offset", TType.I64, 1);
  static final TField _LIMIT_FIELD_DESC = TField("limit", TType.I64, 2);
  static final TField _ORD_COL_FIELD_DESC = TField("ordCol", TType.BYTE, 3);
  static final TField _DESC_FIELD_DESC = TField("desc", TType.BOOL, 4);

  int _offset = 0;
  static const int OFFSET = 1;
  int _limit = 0;
  static const int LIMIT = 2;
  int _ordCol = 0;
  static const int ORDCOL = 3;
  bool _desc = false;
  static const int DESC = 4;


  WalletsGet_args() {
  }

  // offset
  int get offset => this._offset;

  set offset(int offset) {
    this._offset = offset;
  }

  // limit
  int get limit => this._limit;

  set limit(int limit) {
    this._limit = limit;
  }

  // ordCol
  int get ordCol => this._ordCol;

  set ordCol(int ordCol) {
    this._ordCol = ordCol;
  }

  // desc
  bool get desc => this._desc;

  set desc(bool desc) {
    this._desc = desc;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_offset = false;
    bool __isset_limit = false;
    bool __isset_ordCol = false;
    bool __isset_desc = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case OFFSET:
          if (field.type == TType.I64) {
            this.offset = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LIMIT:
          if (field.type == TType.I64) {
            this.limit = iprot.readI64();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ORDCOL:
          if (field.type == TType.BYTE) {
            this.ordCol = iprot.readByte();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DESC:
          if (field.type == TType.BOOL) {
            this.desc = iprot.readBool();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_OFFSET_FIELD_DESC);
    oprot.writeI64(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_LIMIT_FIELD_DESC);
    oprot.writeI64(this.limit);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_ORD_COL_FIELD_DESC);
    oprot.writeByte(this.ordCol);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_DESC_FIELD_DESC);
    oprot.writeBool(this.desc);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletsGet_args(");

    ret.write("offset:");
    ret.write(this.offset);

    ret.write(", ");
    ret.write("limit:");
    ret.write(this.limit);

    ret.write(", ");
    ret.write("ordCol:");
    ret.write(this.ordCol);

    ret.write(", ");
    ret.write("desc:");
    ret.write(this.desc);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class WalletsGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("WalletsGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  WalletsGetResult _success = WalletsGetResult();
  static const int SUCCESS = 0;


  WalletsGet_result() {
  }

  // success
  WalletsGetResult get success => this._success;

  set success(WalletsGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = WalletsGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("WalletsGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TrustedGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TrustedGet_args");
  static final TField _PAGE_FIELD_DESC = TField("page", TType.I32, 1);

  int _page = 0;
  static const int PAGE = 1;


  TrustedGet_args() {
  }

  // page
  int get page => this._page;

  set page(int page) {
    this._page = page;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_page = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PAGE:
          if (field.type == TType.I32) {
            this.page = iprot.readI32();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_PAGE_FIELD_DESC);
    oprot.writeI32(this.page);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TrustedGet_args(");

    ret.write("page:");
    ret.write(this.page);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class TrustedGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("TrustedGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  TrustedGetResult _success = TrustedGetResult();
  static const int SUCCESS = 0;


  TrustedGet_result() {
  }

  // success
  TrustedGetResult get success => this._success;

  set success(TrustedGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = TrustedGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("TrustedGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SyncStateGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SyncStateGet_args");



  SyncStateGet_args() {
  }

  @override
  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SyncStateGet_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class SyncStateGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("SyncStateGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  SyncStateResult _success = SyncStateResult();
  static const int SUCCESS = 0;


  SyncStateGet_result() {
  }

  // success
  SyncStateResult get success => this._success;

  set success(SyncStateResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = SyncStateResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("SyncStateGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ExecuteCountGet_args implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("ExecuteCountGet_args");
  static final TField _EXECUTE_METHOD_FIELD_DESC = TField("executeMethod", TType.STRING, 1);

  String _executeMethod = "";
  static const int EXECUTEMETHOD = 1;


  ExecuteCountGet_args() {
  }

  // executeMethod
  String get executeMethod => this._executeMethod;

  set executeMethod(String executeMethod) {
    this._executeMethod = executeMethod;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_executeMethod = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case EXECUTEMETHOD:
          if (field.type == TType.STRING) {
            this.executeMethod = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  @override
  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_EXECUTE_METHOD_FIELD_DESC);
    oprot.writeString(this.executeMethod);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("ExecuteCountGet_args(");

    ret.write("executeMethod:");
    ret.write(this.executeMethod);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ExecuteCountGet_result implements TBase {
  static final TStruct _STRUCT_DESC = TStruct("ExecuteCountGet_result");
  static final TField _SUCCESS_FIELD_DESC = TField("success", TType.STRUCT, 0);

  ExecuteCountGetResult _success = ExecuteCountGetResult();
  static const int SUCCESS = 0;


  ExecuteCountGet_result() {
  }

  // success
  ExecuteCountGetResult get success => this._success;

  set success(ExecuteCountGetResult success) {
    this._success = success;
  }

  @override
  read(TProtocol iprot) {
    bool __isset_success = false;
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = ExecuteCountGetResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @override
  String toString() {
    StringBuffer ret = StringBuffer("ExecuteCountGet_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

